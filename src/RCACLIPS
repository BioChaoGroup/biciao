#!/usr/bin/env perl
# (c) 2016 - 2019 Chao IN-HORSE SHARE ONLY
# ===================================================================
# Description:       Clipping RCA adaptor(s) from contigs (in a stupid way)
# Author:            Chao | fangchao@genomics.cn
# Version:           V0.0
# Last modified:    23 Aug 2019 (since 23 Aug 2019)
# ===================================================================
# see detail below
use strict;
use Getopt::Long qw(:config no_ignore_case); # For case sensitive

sub usage {
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 -a <adaptor> -k [17] -i <input> -o <output>
    -a  RCA adaptor, default is [AAGTCGGACGCTGATAAGGTCGCCATGCCTCTCAGTACTCCGACTT]
    -k  kmer length, defult is [11].
    -m  minimal output sequence length. default is [100].
    -i  contig fasta file
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
&usage && exit unless @ARGV;

my ($ad,$k,$minLen,$inf,$out,$verbose,$help);
GetOptions(
  "a=s" => \$ad,
  "k=s" => \$k,
  "m=s" => \$minLen,
  "i=s" => \$inf,
  "o=s" => \$out,
  "v" => \$verbose,
  "h|help|?" => \$help,
);
&usage && exit if $help;
&usage("[fatal] Essential input is missing") && exit unless defined $inf;

$ad ||= "AAGTCGGACGCTGATAAGGTCGCCATGCCTCTCAGTACTCCGACTT";
&verbose("[log] Searching RCA adaptor: [$ad]\n");
$k  ||= 11;
$minLen||=100;
&verbose("[log] Using kmer length: [$k]\n");
open INF, ($inf)?"<$inf":"<-" or die $!;
open OUT, ($out)?">$out":">-" or die $!;
`mkdir -p $out.tmp`;
# Main start
## find RCA
open TMP,"> $out.tmp/flank10.m6";
open RCA,">$out.tmp/RCA.fa" or die $!;
print RCA ">RCA\n$ad";
close RCA;
system("makeblastdb -in $out.tmp/RCA.fa -dbtype nucl &>$out.tmp/blast.log");
system("blastn -db $out.tmp/RCA.fa -query $inf -outfmt 6 -out $out.tmp/contig2RCA.m6 &>>$out.tmp/blast.log");
open RCA,"< $out.tmp/contig2RCA.m6" or die $!;
my (%RCAS,@tmp);
while(<RCA>){
  chomp;
  my @a = split;
  my @p = sort {$a<=>$b} ($a[6],$a[7]);
  unless(defined $RCAS{$a[0]}){
    $RCAS{$a[0]}{$p[0]} = $p[1];
    @tmp = @p;
  }else{
    my $keep=1;
    for(my $i=$p[0];$i<=$p[1];$i++){
      if(grep /$i/, @tmp){$keep=0;last};
    }
    if($keep){
      $RCAS{$a[0]}{$p[0]} = $p[1];
      push @tmp, @p;
    }
  }
}
&verbose("[log] Start ... ");
## Reading input
$/=">";
while(<INF>){
  chomp;
  my($hit,$thisKmer,$sLen,$pattern,%CLIPS)=(0,);
  #$/="\n";
  my @a = split(/\n/,$_);
  my $id = shift @a;
  my $seq = join('',@a);
  next if $id eq "";
  $sLen = length($seq);
  my @a = split(/\t|\s/,$id);
  my @ks = (sort {$a<=>$b} keys %{$RCAS{$a[0]}});
  if(@ks == 0){
    print OUT ">$id CLIP=0 len=$sLen\n$seq\n";
  }else{
    #pick flank left side of the first RCA adaptor:
    my $fl0 = $ks[0];
    my $flank0 = substr($seq,0,$ks[0]);
    # print middle-region segments:
    for(my $i=0;$i<$#ks;$i++){
      my $fLen = $ks[$i+1] - $RCAS{$a[0]}{$ks[$i]};
      my $flank = substr($seq,$RCAS{$a[0]}{$ks[$i]},$fLen);
      print OUT ">$id CLIP=".($i+1)." len=$fLen\n$flank\n" if $fLen >= $minLen;
    }
    #pick flank right side of the last RCA adaptor:
    my $fl1 = $sLen - $RCAS{$a[0]}{$ks[$#ks]};
    my $flank1 = substr($seq,$RCAS{$a[0]}{$ks[$#ks]},$fl1);
    # join if flank0 and flank1 are ovelaped.
    if($fl1>0 && $fl2>0){
      my $cmd;
      $cmd = "echo -e \">$a[0]\.0_$fl0\n$flank0\" > $out.tmp/tmp.0.fa";
      #print $cmd;
      system($cmd);
      $cmd = "echo -e \">$a[0]\.1_$fl1\n$flank1\" > $out.tmp/tmp.1.fa";
      #print $cmd;
      system($cmd);
      $cmd = "makeblastdb -in $out.tmp/tmp.0.fa -dbtype nucl &>> $out.tmp/blast.log";
      #print $cmd;
      system($cmd);
      #$cmd = "blastn -db $out.tmp/tmp.0.fa -query $out.tmp/tmp.1.fa -outfmt 6 -out $out.tmp/$a[0]\.m6 &>$out.tmp/blast.log";
      $cmd = "blastn -db $out.tmp/tmp.0.fa -query $out.tmp/tmp.1.fa -outfmt 6 2>>$out.tmp/blast.log";
      #print $cmd;
      my $res = `$cmd`;
      my $join ="";
      if($res){
        print TMP $res;
        my @a = split(/\t/,$res);
        my @p1 = sort {$a<=>$b} ($a[6],$a[7]);
        my @p0 = sort {$a<=>$b} ($a[8],$a[9]);
        if ( @p1[1] > 0.5 * $fl1 && @p0[0] < 0.5 * $fl0 && $a[6] < $a[7] && $a[8] < $a[9]) {
          $join = substr($flank1,0,$p1[0]-1).substr($flank0,$p0[0]-1,$fl0-$p0[0]+1);
        }
      }
    }
    if($join){
      print OUT ">$id CLIP=".($#ks+1)."0 len=".length($join)."\n$join\n";
    }else{
      if($fl1 >= $minLen){
        print OUT ">$id CLIP=".($#ks+1)." len=$fl1\n$flank1\n";
      }else{
        &verbose("$id CLIP=".($#ks+1)." len=$fl1 #skip due to length limitation\n")
      }
      if($fl0 >= $minLen){
        print OUT ">$id CLIP=0 len=$fl0\n$flank0\n";
      }else{
        &verbose("$id CLIP=0 len=$fl0 #skip due to length limitation\n")
      }
    }
  }
  #prep for next loop
  #$/=">";
}

close TMP;
close INF;
close OUT;
# Main end

&verbose("done!\n");

exit;

sub verbose{
  my $msg = shift;
  print STDERR $msg if $verbose;
}
