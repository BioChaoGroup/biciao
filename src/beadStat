#!/usr/bin/env perl
# (c) 2016 - 2019 Chao IN-HORSE SHARE ONLY
# ===================================================================
# Description:       stat the overlap depth between each 2 beads.
# Author:            Chao | fangchao@genomics.cn
# Version:           v0.1
# Last modified:     03 Jan 2019 (since 03 Jan 2019)
# ===================================================================
# see detail below
use strict;
use Getopt::Long;
my (%CLUST);
my($verbose,$help);
sub usage {
  my $msg = shift;
print <<USAGE;
$msg
usage:
  beadStat <mode> [option]
  mode:
    uc     Stat the overlap depth between each 2 beads
    merge  Merge 2 cluster files together
    bc     output best anno with specified cutoffs
    bin    filter fq files with beads above a threashold
    RBS    Reads supports from Beads to Scaffolds
    sam    stat beads mapping proportion from bwa alignment result

options:  Defined according to the mode and cmd you chosed.
USAGE
}

&usage("Stating beads related information") && exit if @ARGV == 0 || $ARGV[0] eq "-h";

my $mode = shift @ARGV unless $ARGV[0] =~/^-/;

# Main start
&run_uc    if $mode eq "uc";
&run_merge if $mode eq "merge";
&run_BCent if $mode eq "bc";
&run_rbs   if $mode eq "RBS";
&run_sam   if $mode eq "sam";
&run_sam2b if $mode eq "sam2b";
# Main end

&verbose("[log] All done!\n");

exit;

sub verbose{
  my $msg = shift;
  print STDERR $msg if $verbose;
}

sub BC2Num {
  my $id = shift;
  my $num= shift;
  $num ||= '1';
  $id =~ /[@\/](\d+)_(\d+)_(\d+)\//;
  $id = "$1\_$2\_$3";
  my $status = ($id =~ /0000/)?"F":"T"; # FAIL or TRUE BARCODE
  return($id,$status);
}

##########################

sub usage4uc {
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 uc -i input -o output
    -i  unchime file with 10 column
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
&usage4uc("Stat the overlap depth between each 2 beads.") && exit unless @ARGV;

sub run_uc {
  my (%CLUST);
  my ($inf,$ident,$match,$out,$verbose,$help);
  GetOptions(
    "i=s" => \$inf,
    "ident=i" => \$ident,
    "match=i" => \$match,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4uc("Stat the overlap depth between each 2 beads.") && exit if $help;
  #&usage("[fatal] Essential input is missing");

  $ident||= 98;
  $match||= 30;
  #open INF, ($inf)?"<$inf":"<-" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;

  &verbose("[log] Mode [UC] start ... \n");
  my(%HASH,%CLUST,%STAT,$clusterCount,$linkCount);
  #Here is the shorts for each column. Find more detail in VSEARCH manual.
  ##   0         1       2            3            4  5  6      7     8        9##
  ##Type  #Cluster  length  similarity%  orientation  *  *  CIGAR query centroid##
  open INF, ($inf)?"<$inf":"<-" or die $!;
  while(<INF>){
    if($. % 1000000 == 0 ){
      &verbose("[log] lines: $. | links: $linkCount | cluster: $clusterCount\n");
    }
    $clusterCount ++ if $_ =~ /^S/;
    %CLUST = () && next if $_ =~ /^[CS]/; #Before the start of a new cluster
    chomp;
    my @info = split(/\t/,$_);
    my $iMatch = ($info[7] =~ /(\d+)M/)?$1:$info[2];
    $STAT{'O'} ++ && next if $iMatch < $match || $info[3] < $ident;  #Skip when identity or length less than cutoff;

    my ($BC0,$BC1,$BC8,$BC9,$s0,$s8,$s9) = (); #init
    unless (%CLUST){
      ($BC9,$s9) = &BC2Num($info[9]);
      $CLUST{$BC9} = 1 if $s9 eq "T";
    }
    ($BC8,$s8) = &BC2Num($info[8]);
    $STAT{'F'} ++ && next if $s8 eq "F";

    foreach my $BC9 (keys %CLUST){
      $STAT{'S'} ++ && next if $BC8 eq $BC9 || $BC9 eq "";
      $BC0 = ($BC8 lt $BC9)?$BC8:$BC9;
      $BC1 = ($BC8 lt $BC9)?$BC9:$BC8;
      $linkCount ++ unless defined $HASH{$BC0}{$BC1}{'count'};
      #$HASH{$BC0}{$BC1}{'status'} = ($BC0 eq $BC1)?"S":"T" unless defined $HASH{$BC0}{$BC1}{'status'};
      $HASH{$BC0}{$BC1}{'count'} ++;
      $HASH{$BC0}{$BC1}{'length'} += $info[2];
      $STAT{'T'} ++;
    }
    $CLUST{$BC8} = 1;
  }
  close INF;
  &verbose("[log] Finish read. stat ... \n");

  foreach my $BC0 (sort keys %HASH){
    foreach my $BC1 (sort keys %{$HASH{$BC0}}){
      my $status  = "T";#$HASH{$BC0}{$BC1}{'status'};
      my $count   = $HASH{$BC0}{$BC1}{'count'};
      my $length  = $HASH{$BC0}{$BC1}{'length'} / $count;
      my $output = sprintf("%s\t%s\t%s\t%5d\t%7.2f\n",
      $status, $BC0, $BC1, $count, $length);
      printf OUT $output;
    }
  }
  close OUT;
  &verbose(sprintf("[log] DUPLICATES SUMMARY:\n\nclusters\tedges\n%d\t%d\n",
  $clusterCount,$linkCount));
  &verbose(sprintf("[log] READS PAIR SUMMARY:\n\nFAIL\tSELF\tKEPT\n%d\t%d\t%d\n\n",
  $STAT{F},$STAT{S},$STAT{T}));
  &verbose("[log] Mode [UC] done ... \n");
}

sub run_merge {
  my (%CLUST);
  my ($inf,$ident,$match,$out,$verbose,$help);
  GetOptions(
    "i=s" => \$inf,
    "ident=i" => \$ident,
    "match=i" => \$match,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4uc("Merge 2 cluster files together.") && exit if $help;
  #&usage("[fatal] Essential input is missing");

  $ident||= 98;
  $match||= 30;
  #open INF, ($inf)?"<$inf":"<-" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;

  &verbose("[log] Mode [merge] start ... \n");
  my @files = split (",",$inf);
  &verbose("[err] [merge] needs two files. Pls check\n") & die $! if @files != 2;
  open IN1, "<$files[0]" or die $!;
  open IN2, "<$files[1]" or die $!;
  #Here is the shorts for each column.
  ##   0         1         2      3       4##
  ##Type  Barcode1  Barcode2  count  length##
  my ($run1, $run2, $count1, $count2) = (1,1,0,0);
  chomp(my $read1 = <IN1>);
  my @inf1 = split (/\t/,$read1);
  chomp(my $read2 = <IN2>);
  my @inf2 = split (/\t/,$read2);

  while($run1 && $run2){

    while($run1 && "$inf1[1] $inf1[2]" lt "$inf2[1] $inf2[2]"){
      $count1 ++;
      print OUT "$read1\n";
      chomp($read1 = <IN1>);
      $run1 = 0 && close IN1 if $read1 eq <EOF>;
      @inf1 = split (/\t/,$read1);
    }

    while("$inf1[1] $inf1[2]" eq "$inf2[1] $inf2[2]"){
      my $length = ($inf1[3] * $inf1[4] + $inf2[3] * $inf2[4]) / ($inf1[3] + $inf2[3]);
      my $output = sprintf("%s\t%s\t%s\t%5d\t%7.2f\n",
      $inf1[0], $inf1[1], $inf1[2], $inf1[3] + $inf2[3], $length);

      $count1 ++; $count2 ++;
      print OUT $output;

      chomp($read1 = <IN1>);
      @inf1 = split (/\t/,$read1);
      chomp($read2 = <IN2>);
      @inf2 = split (/\t/,$read2);
    }

    while($run2 && "$inf1[1] $inf1[2]" gt "$inf2[1] $inf2[2]"){
      $count2 ++;
      print OUT "$read2\n";
      chomp($read2 = <IN2>);
      $run2 = 0 && close IN2 if $read2 eq <EOF>;
      @inf2 = split (/\t/,$read2);
    }
    if($count1 % 1000000 == 0 || $count2 % 1000000 == 0){
      &verbose(sprintf("[log] Processing | file1: %9d | file2: %9d\n", $count1, $count2));
    }
  }
  &verbose("[log] file1 closed.\n") unless $run1;
  &verbose("[log] file2 closed.\n") unless $run2;
  while($run1){
    $count1 ++;
    print OUT "$read1\n";
    chomp($read1 = <IN1>);
    $run1 = 0 && close IN2 if $read1 eq <EOF>;
    @inf1 = split (/\t/,$read1);
  }
  while($run2){
    $count2 ++;
    print OUT "$read2\n";
    chomp($read2 = <IN2>);
    $run2 = 0 && close IN2 if $read2 eq <EOF>;
    @inf2 = split (/\t/,$read2);
  }

  close OUT;
  &verbose("[log] Mode [merge] done ... \n");
}

sub usage4bc {
  my $msg = shift;
  print <<USAGE;
$msg
usage [v0.1] :
  beadStat bc -i input -ident [identity] -match [match] -o output -v -h
    -i  annotation of scaffolds
    -o  output
    -v  verbose
    -h  show help info
USAGE
}

sub run_BCent {
  &usage4bc("Found Bead Clusters' center\n") && exit if $help;
  my ($inf,$ident,$match,$out,$verbose,$help);
  GetOptions(
    "i=s" => \$inf,
    "ident=i" => \$ident,
    "match=i" => \$match,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4bc("Found Bead Clusters' center\n") && exit if $help;
  #&usage("[fatal] Essential input is missing");

  $ident||= 98;
  $match||= 30;
  #open INF, ($inf)?"<$inf":"<-" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;

  &verbose("[log] Mode [Bead Centroid] start ... \n");
  my (%STAT,$RCCount,$BCCount);
  #Here is the shorts for each column. Find more detail in VSEARCH manual.
  ##   0         1       2            3            4  5  6      7     8        9##
  ##Type  #Cluster  length  similarity%  orientation  *  *  CIGAR query centroid##
  open INF, ($inf)?"<$inf":"<-" or die $!;
  $RCCount = 0;
  $BCCount = 1;
  while(<INF>){
    next if $_ =~ /^C/;
    if($. % 1000000 == 0 ){
      &verbose("[log] lines: $. | RC: $RCCount | BC: $BCCount\n");
    }
    if($_ =~ /^S/){
      &writePreCluster;
      %CLUST = () ;
      $RCCount ++ ;
    }
    chomp;
    my @info = split(/\t/,$_);
    #my $iMatch = ($info[7] =~ /(\d+)M/)?$1:$info[2];
    #$STAT{'O'} ++ && next if $iMatch < $match || $info[3] < $ident;  #Skip when identity or length less than cutoff;

    my ($BC0,$BC1,$BC8,$BC9,$s0,$s8,$s9) = (); #init
    ($BC8,$s8) = &BC2Num($info[8]);
    if($CLUST{$BC8}{'S'}){
      $CLUST{$BC8}{'H'}{$CLUST{$BC8}{'C'}} = sprintf("H\t%8d\t%3d\t%5s\t%s\t%s\t%s\t%s\t%s\t%s\n",
      $BCCount-1,$info[2],$info[3],$info[4],$info[5],$info[6],$info[7],$info[8],$CLUST{$BC8}{'Center'});
      $CLUST{$BC8}{'C'} ++;
    }else{
      $CLUST{$BC8}{'S'} = sprintf("S\t%8d\t%3d\t%5s\t%s\t%s\t%s\t%s\t%s",
      $BCCount-1,$info[2],$info[3],$info[4],$info[5],$info[6],$info[7],$info[8]);

      $CLUST{$BC8}{'C'} = 1;
      $CLUST{$BC8}{'Center'} = $info[8];
      $BCCount ++;
    }
  }

  close INF;
  close OUT;

  &verbose("[log] Mode [Bead Centroid] done ... \n");
}

sub writePreCluster{
  return(1) unless %CLUST;
  foreach my $BC (sort keys %CLUST){
    print OUT "$CLUST{$BC}{'S'}\t$CLUST{$BC}{'C'}\n";
    print "$BC\t$CLUST{$BC}{'C'}\n";
    foreach my $HT (sort {$a<=>$b} keys %{$CLUST{$BC}{'H'}}){
      print OUT "$CLUST{$BC}{'H'}{$HT}";
    }
  }
}

sub usage4rbs {
  my $msg = shift;
  print <<USAGE;
$msg
usage [v0.1] :
  beadStat.pl RBS -r  bb2scaf -a anno -o output
    -r  alignment from reads to scaffolds, sam format
    -a  annotation of scaffolds
    -o  output
    -v  verbose
    -h  show help info
USAGE
}

sub run_rbs {
  &usage4rbs("stat reads supports for beads to scaffolds") && exit unless @ARGV;
  my ($r2s,$anno,$out);
  GetOptions(
    "r=s" => \$r2s,
    "a=s" => \$anno,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4best("stat reads supports for beads to scaffolds") && exit if $help;
  &verbose("[RBS] Mode start ... \n");
  #Init
  open INR,"<$r2s" or die "Cannot open alignment file: $r2s.\n";
  open INA,"<$anno" or die "Cannot open annoatation file: $anno.\n";
  open OUT,">$out" or die "Cannot open output file: $out.\n";
  my (%R2S,%ANNO);
  while(<INR>){
    chomp;
    next if $_ =~ /^@/;
    my @r=split (/\t/);
    #my @r2=split (/\t/,<INR>);
    $r[0] =~ /\/(\d+_\d+_\d+)$/; my $bb = $1;
    $R2S{$bb}{'sum'} ++;
    $R2S{$bb}{'hit'}{$r[2]} ++;

    #Alternative position
    my @ats =();
    @ats = split (/;/,$1) if $_ =~ /XA:Z:(.+);/;
    unless(@ats){
      $R2S{$bb}{'uniq'}{$r[2]} ++;
    }
    while(@ats){
      my $at = shift @ats;
      if($at=~/(NODE_\d+_length_\d+_cov_[0-9.]+),/){
        $R2S{$bb}{'hit'}{$1} ++;
      }
    }
  }
  close INR;
  while(<INA>){
    chomp;
    my @a = split(/\t/);
    $ANNO{$a[0]}{$a[12]} = sprintf("%s(%6.2f\%,%4dbp)",$a[12],$a[2],$a[3]);
  }
  &verbose("[RBS] Writing ...\n");
  foreach my $BB (sort keys %R2S){
    foreach my $ND (sort keys %{$R2S{$BB}{'hit'}}){
      print OUT sprintf("%s\t%-36s\t%6d(%6.2f\%)\t%6d(%6.2f\%)\t%18s\t%18s\t%18s\t%18s\t%18s\n",
      $BB,$ND, $R2S{$BB}{'uniq'}{$ND},100*$R2S{$BB}{'uniq'}{$ND}/$R2S{$BB}{'sum'},
      $R2S{$BB}{'hit'}{$ND},100*$R2S{$BB}{'hit'}{$ND}/$R2S{$BB}{'sum'},
      $ANNO{$ND}{Sc},$ANNO{$ND}{Fv},$ANNO{$ND}{Le},$ANNO{$ND}{Pe},$ANNO{$ND}{Hm});
    }
  }
  &verbose("[RBS] Mode done!\n");
}

sub usage4sam {
  my $msg = shift;
  print <<USAGE;
$msg
usage [v0.1] :
  beadStat SAM -i <sam file> -o output
    -i  input sam file
    -o  output
    -v  verbose
    -h  show help info
USAGE
}

sub run_sam {
  &usage4sam("stat beads number to each reference") && exit unless @ARGV;
  my ($inf,$out);
  GetOptions(
    "i=s" => \$inf,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4sam("stat beads number to each reference") && exit if $help;
  &verbose("[SAM] Mode start ... \n");
  #Init
  open INF,"<$inf" or die "Cannot open alignment file: $inf.\n";
  open OUT,">$out" or die "Cannot open output file: $out.\n";
  my (%B2R,$pBB,$count);
  while(<INF>){
    chomp;
    next if $_ =~ /^@/;
    my @r=split (/\t/);
    $r[0] =~ /\/(\d+_\d+_\d+)$/;
    my $bb = ($1 =~ /0000/)?"0000_0000_0000":$1;
    if ($pBB ne $bb){
      &samout($pBB,\%B2R,$count);
      %B2R = ();
      $count = 0;
    }
    $count ++;
    next if $r[6] ne "=";
    my %HS;
    $HS{$r[2]} ++; #if $r[5] eq "100M";
    my $alter1 = ($_ =~ /XA:Z:(\S+)$/)?$1:"";
    $_ = <INF>; @r=split (/\t/);
    $HS{$r[2]} ++; #if $r[5] eq "100M";
    my $alter2 = ($_ =~ /XA:Z:(\S+)$/)?$1:"";
    my @a = (split(/;/,$alter1), split(/;/,$alter2));
    while(@a){
      my $xa = shift @a;
      $xa =~ /(\S+),[+-]\d+,(\S+),(\S+)/;
      $HS{$1} ++; #if $2 eq "100M";
    }
    my @alts = ();
    foreach my $H (keys %HS){
      push @alts, $H if $HS{$H} >1;
    }
    my $hitType = (@alts>1)?"MULT":"UNIQ";

    while(@alts){
      my $hit = shift @alts;
      $B2R{$hit}{$hitType} ++;
    }
    $pBB = $bb;
    #verbose
    if($. % 1000000 == 0 ){
      &verbose(sprintf("\r[SAM] $. lines read. Last BB is [%s]",$bb));
    }
  }
  &verbose("\n");
  close INF;
  &samout($pBB,\%B2R,$count);
  close OUT;
  &verbose("[SAM] Mode done!\n");
}

sub samout {
  my $B  = shift;
  my $HS = shift;
  my $ct = shift;
    foreach my $H (sort keys %$HS){
      $$HS{$H}{UNIQ} ||=0;
      $$HS{$H}{MULT} ||=0;
      print OUT "$B\t$H\t$$HS{$H}{UNIQ}\t$$HS{$H}{MULT}\t$ct\n";
  }
}

sub run_sam2b {
  &usage4sam("stat beads stat to beads represent") && exit unless @ARGV;
  my ($inf,$out);
  GetOptions(
    "i=s" => \$inf,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4sam("stat beads number to each reference") && exit if $help;
  &verbose("[SAM] Mode start ... \n");
  #Init
  open INF,"<$inf" or die "Cannot open alignment file: $inf.\n";
  open OUT,">$out" or die "Cannot open output file: $out.\n";
  my (%B2B,%HS,$uSum,$mSum,$pBB,$count);
  while(<INF>){
    chomp;
    next if $_ =~ /^@/;
    my @r=split (/\t/);
    my $bb = $r[0]; $bb = "0000_0000_0000" if $bb =~ /0000/;
    if ($pBB ne $bb){
      &sambout($pBB,\%B2B,$count);
      ($count,%B2B,$uSum,$mSum) = (0,);
    }
    $B2B{$r[1]}{UNIQ} = $r[2];
    $B2B{$r[1]}{MULT} = $r[3];
    $count = $r[4];
    $pBB = $bb;
    #verbose
    if($. % 1000000 == 0 ){
      &verbose(sprintf("\r[SAM] $. lines read. Last BB is [%s]",$bb));
    }
  }
  &verbose("\n");
  close INF;
  &sambout($pBB,\%B2B,$count);
  close OUT;
  &verbose("[SAM] Mode done!\n");
}

sub sambout{
  my $B = shift;
  my $HS = shift;
  my $ct = shift;
  return unless $B;
  my ($k1, $k2,$CT,$US,$MS) = ("MISS","MISS",0,0,0);
  foreach my $H (keys %$HS){
    $CT ++;
    $US += $$HS{$H}{UNIQ};
    $MS += $$HS{$H}{MULT};
    if($$HS{$H}{UNIQ}>($$HS{$k1}{UNIQ}||=0)){
      $k2 = $k1; $k1 = $H;
    }elsif($$HS{$H}{UNIQ}>($$HS{$k2}{UNIQ}||=0)){
      $k2 = $H;
    }
  }
  print OUT sprintf("%s\t%d\t%d\t%d\t%s\t%d\t%d\t%s\t%d\t%d\n", $B,$ct,$US,$MS,
  $k1,$$HS{$k1}{UNIQ},$$HS{$k1}{MULT}, $k2,$$HS{$k2}{UNIQ},$$HS{$k2}{MULT});
}
